{
    "contents" : "rm(list = ls())\nsource(\"nagelkerke_rossberg_suppl/nagelkerke_rossberg_Rcode/nichespace.R\")\n\n# Set some parameters for the random community ------\nn.r = 25\nn.c = 36\nntraits.r=4\nntraits.c=6\n\n# Random normal trait data\nmock <- niche.mock.data(n.r = 25,\n                        n.c = 36,\n                        ntraits.r=4,\n                        ntraits.c=6,\n                        b=0,\n                        C=NA)\n\nQF <- niche.quadratic.form(mock$traits.r,mock$traits.c,mock$interactions)\n\n\n# Extracting vectors and matrices ----------------------\n# What is x? x is any combination of resource and consumer \n# traits concatenated together\n# would that be all cobinations of resorce consumer?\n# Yes, because it would have to fill the whole interaction matrix\n\n# One random species\nx <- c(mock$traits.r[sample(1:n.r, 1),], mock$traits.c[sample(1:n.c,1),])\n\nb <- QF$b\nC <- QF$C\na <- QF$a\nu <- eigen(QF$C)$vectors # There is one dominant eigenvalue corresponding to a\n# single pair of trophic traits.  The corresponding\n# eigenvector (last column) shows which traits are involved.\n\nlk <- eigen(QF$C)$values\n\n# Traits vuln + foraging\nDprime = ntraits.c + ntraits.r\nv <-  x[1:ntraits.r]\n\n# Testing the model\n# Logarithm of the link strength function\na + (t(b) %*% x) + 0.5 * (t(x) %*% (C %*% x))\nniche.loga(v,x[(ntraits.r+1):(ntraits.r+ntraits.c)],QF)\n\n# Link strength\nexp(a + niche.dot(b, x) + 0.5 * niche.dot(x, C %*% x))\nniche.a(x[1:ntraits.r],x[(ntraits.r+1):(ntraits.r+ntraits.c)],QF)\n\n\n# Equation 8.11 Reconstruct the C matrix  ----------\nC_rec <- matrix(0, nrow = Dprime, ncol = Dprime)\n\nfor(k in 1:Dprime){\n  C_k <- (as.matrix(u[,k])*lk[k]) %*% t(as.matrix(u[,k]))\n  C_rec <- C_rec + C_k\n}\n\n# This is true up to some rounding\nround(C,4) == round(C_rec, 4)\n\n\n# Equation 8.12 ------------\n# for species 1\n\nspecies = 1\nx <- c(mock$traits.r[species,], \n       mock$traits.c[species,])\n\nv = x[1:ntraits.r]\n\nf = x[(ntraits.r+1):(ntraits.r+ntraits.c)]\n\n# What about x = sum(u_k (u_k^Tx))\nx_rec <- vector(\"numeric\", length = Dprime)\n\nfor (k in 1:Dprime){\n  x_k <- u[,k] %*% (t(u[,k]) %*% x)\n  x_rec <- x_rec + x_k\n}\n\nround(x_rec,4) == round(x, 4)\n\n# Equation 8.13 after decomposition ---------------------------\n\nbuux <- 0\nfor (k in 1:Dprime){\n  buux <- buux + (t(b)%*%u[,k] * t(u[,k])%*%x)\n}\n\nlkux2 <- 0\nfor (k in 1:Dprime){\n  lkux2 <- lkux2 + lk[k] * (t(u[,k])%*%x)^2\n}\n\n# log link\nll <- a + buux + 0.5 * lkux2\n\nexp(ll)\n\n# compare with a value predicted by function niche.a\nniche.a(v,f,QF)\n\n\n## Reduction of the number of trophic traits ------------------\n\n# If  the $u^T_kX$ are approximately normally distributed\n# as they likely will be because they are given by the sums \n# of independent random numbers. \n# $$ \\frac{1}{4} \\sum_{k=D+1}^{D^{'}} var[\\lambda_k(\\mathbf{u}^T_k\\mathbf{x})^2 ] = \\frac{1}{2} \\sum_{k=D+1}^{D^{'}}\\labda^2_k $$\n# Choosing the truncation D large enough that this erroe remains within \n# acceptable bounds:\n\n## Equation 8.15 -----------------\nD <- 10\n\nlk_inv = lk[order(lk)]\nu_inv = u[, order(lk)]\n\nbuux_Dprime <- 0\n# for (k in 1:Dprime){\n#   buux_Dprime <- buux_Dprime + (t(b)%*%u_inv[,k] * t(u_inv[,k])%*%x)\n# }\n\nfor (k in 1:Dprime){\n  buux_Dprime <- buux_Dprime + (t(b)%*%u[,k] * t(u[,k])%*%x)\n}\n\nlkux2_D <- 0\n\nfor (k in 1:D){\n  lkux2_D <- lkux2_D + lk[k] * (t(u[,k])%*%x)^2\n}\n\n# for (k in 1:D){\n#   lkux2_D <- lkux2_D + lk_inv[k] * (t(u_inv[,k])%*%x)^2\n# }\n\nlk_2 <- sum((lk[(D+1):Dprime])/2)\nlk_2 <- 0\n# log link\n\nllreal <- a + buux_Dprime + 0.5 * lkux2_D + lk_2\n\nexp(llreal)\n\n\n# Why it does not give a better approximation??\n\n# Are eigenvalues not ordered????\n\nllappr <- a + buux + 0.5 * lkux2_D + lk_2\n\nexp(llappr)\n\n## Why it doesnt match the real value?\nniche.a(v,f,QF)\n\n\n\n## Equation 8.16 ----------------------------------------------\n\nt(u[,1]) %*% as.matrix(x)\n\nv <- mock$traits.r\nf <- mock$traits.c\n\ng1v <- t(u[1:ntraits.r, 1]) %*% v[1, ]\nh1f <- t(u[(ntraits.r+1):(ntraits.r + ntraits.c), 1]) %*% f[1, ] \n\nVk <- g1v + h1f\nFk <- -h1f\n\n# Baseline trophic traits\nVbase <- 0\nfor(k in 1:Dprime){\n  Vbase <- Vbase + t(u[1:ntraits.r, k]) %*% v[k, ]\n}\n\nFbase <- 0\nfor(k in 1:Dprime){\n  Fbase <- Fbase + t(u[(ntraits.r+1):(ntraits.r + ntraits.c), k]) %*% f[k, ] \n}\n\n# Equation 8.19 -----------------------------------------------\n\nlkVkFk <- 0\nfor ()\n\nlogA = a + (Vbase + Fbase + 0.5 * lkVkFk)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Components of v and f have to be uncorrelated and have variance 1\n# and mean 0, effect of their concatenation should therefore have \n# the same properties.\n\nvec <- c()\nfor (k in 1:Dprime){\n  vec <- c(vec, (t(u[,k])%*%x))\n}\n\n\n\n\n\nweights.r <- 1\nrho.r <- 1\n\nt <- as.matrix(traits.r)\n# s <- as.matrix(traits.c)\n\n# Some more abbreviations:\nn.r <- dim(t)[1]\n# n.c <- dim(s)[1]\n# ntraits.r <- dim(t)[2]\n# ntraits.c <- dim(s)[2]\n\n# Make sure weights and abundances are of the right form, and\n# introduce abbreviations g and h in line with theory:\ng <- array(as.vector(weights.r),n.r)\n# h <- array(as.vector(weights.c),n.c)\nrho.r <- array(as.vector(rho.r),n.r)\n# rho.c <- array(as.vector(rho.c),n.c)\n\n# Normal approximation for resource trait distribution:\nC.u <- cov.wt(t, wt=as.vector(rho.r*g), method=\"ML\")\n# (Note: Since we are using weights, \"ML\" is the better choice!)\nmu.u <- C.u$center\nC.u <- C.u$cov\n\n\n# Check if standardization works for traits form crazy distributions and for the mixture\n# of distributions\n\nspec = 10\ntrai = 6\n\nrbinom(trai, 1, p=0.7)\nrnorm(trai,10, 2)\nrexp(trai, 0.2)\nrunif(trai)\n\ntraitmat = matrix(0,nrow=spec, ncol = trai)\ntraitmat[,1]\n",
    "created" : 1545479686874.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "902464538",
    "id" : "D4F001FF",
    "lastKnownWriteTime" : 1545480011,
    "path" : "~/GitHub/pdmmmodel/exploring_link_strenths.R",
    "project_path" : "exploring_link_strenths.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "type" : "r_source"
}